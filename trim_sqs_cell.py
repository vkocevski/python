#! /usr/bin/env python
#
# The script copies sqscell.out (generated by mcsqs) to old-sqscell.out.
# Then trims the sqscell.out using the defined angle and lattice parameter
# tolerance. Saves a defined number of supercell in new-sqscell.out.
# The new supercells are listed in a ascending order of the lattice parameter
# discrepancy error, starting from the supercell with smallest error.
# Put --nc 1 for the best supercell to be used for further calculations
import numpy as np
import argparse

# User defined options
parser = argparse.ArgumentParser()
parser.add_argument('--ang', type=float, required=True, help='Lowest angle of the supercell (in degrees')
parser.add_argument('--da', type=float, required=True, help='Lattice parameter tolerance (in Ang)')
parser.add_argument('--nc', type=int, required=True, help='Numer of cells')
args = parser.parse_args()
lima1 = args.ang
lima2 = 180-lima1
da = args.da
ncell = args.nc

# Read the original file
with open('sqscell.out') as f1:
    lines = f1.readlines()

# Save the original file
with open('old-sqscell.out', 'w') as f2:
    for x in lines: f2.write(x)

# Generate new file with desired supercell
with open('new-sqscell.out', 'w') as f3:
    tot = int(lines[0].split()[0])  # total number of cells
    count = 0
    arr1 = np.zeros((ncell,3,3))
    dlp_min = []
    dlp_min = [1000 for i in range(ncell)]
    d = 0.0000000001
    for i in range(tot):
        a=[0, 0, 0]
        b=[0, 0, 0]
        c=[0, 0, 0]
        lp=[0, 0, 0]
        dt=[0, 0, 0]
        ang=[0, 0, 0]
        dlp = [0, 0, 0]
        a = [ float(x) for x in lines[4*i+2].split() ]
        b = [ float(x) for x in lines[4*i+3].split() ]
        c = [ float(x) for x in lines[4*i+4].split() ]
        lp[0] = np.sqrt(np.sum(np.power(a,2)))
        lp[1] = np.sqrt(np.sum(np.power(b,2)))
        lp[2] = np.sqrt(np.sum(np.power(c,2)))
        dt[0] = np.sum(np.multiply(a,b))
        dt[1] = np.sum(np.multiply(a,c))
        dt[2] = np.sum(np.multiply(b,c))
        ang[2] = np.arccos(dt[0]/(lp[0]*lp[1]))*180/np.pi
        ang[1] = np.arccos(dt[1]/(lp[0]*lp[2]))*180/np.pi
        ang[0] = np.arccos(dt[2]/(lp[1]*lp[2]))*180/np.pi
        if ang[0] >= lima1 and ang[0] <= lima2 and ang[1] >= lima1 and ang[1] <= lima2 and ang[2] >= lima1 and ang[2] <= lima2:
            dlp[0] = abs(lp[0] - lp[1])
            dlp[1] = abs(lp[0] - lp[2])
            dlp[2] = abs(lp[1] - lp[2])
            if (dlp[0] < da and dlp[1] < da and dlp[2] < da):
                dlp2 = np.sum(np.power(dlp,2))
                count += 1
                for n in range(ncell):
                    if dlp2 < dlp_min[n]:
                        dlp_min[n] = dlp2
                        arr1[n][0] = a
                        arr1[n][1] = b
                        arr1[n][2] = c
                        break

    if (count > 0 and count > ncell):
        f3.write(str(ncell) + '\n\n')
        for i in range(ncell):
            f3.write("{:.6f} {:.6f} {:.6f}\n".format(arr1[i][0][0], arr1[i][0][1], arr1[i][0][2]))
            f3.write("{:.6f} {:.6f} {:.6f}\n".format(arr1[i][1][0], arr1[i][1][1], arr1[i][1][2]))
            f3.write("{:.6f} {:.6f} {:.6f}\n".format(arr1[i][2][0], arr1[i][2][1], arr1[i][2][2])+'\n')
    elif (count > 0 and count <= ncell):
        f3.write(str(count) + '\n\n')
        for i in range(count):
            f3.write("{:.6f} {:.6f} {:.6f}\n".format(arr1[i][0][0], arr1[i][0][1], arr1[i][0][2]))
            f3.write("{:.6f} {:.6f} {:.6f}\n".format(arr1[i][1][0], arr1[i][1][1], arr1[i][1][2]))
            f3.write("{:.6f} {:.6f} {:.6f}\n".format(arr1[i][2][0], arr1[i][2][1], arr1[i][2][2])+'\n')
    else:
        print("No cells within the given parameters, change angle or tolerance")
